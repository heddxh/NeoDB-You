## OpenAPI Document Location

The OpenAPI document is available at [https://neodb.social/api/docs](https://neodb.social/api/docs).
It is generated by `django-ninja`.

## Why is the top-level `build.gradle.kts` empty?

Since this is a single-module project, all plugins and dependencies are declared in the `:app`
module.

## About `Modifier`

In my composable functions, `Modifier` should be the last parameter and passed to the first child
that emits UI (e.g., `Row`, `Text`, etc.).

### Why isn't the latter `Modifier.fillMaxSize` working?

In layouts like `Row`, where child composables are measured from left to right, if an earlier
composable already uses `Modifier.fillMaxSize`, subsequent composables won't receive any remaining
space.

### Performance of `Modifier.clickable`

Instead of using `Modifier.clickable {}`, using the other overload to skip unnecessary
recomposition:

```kotlin
Modifier.clickable(
    interactionSource = null,
    indication = LocalIndication.current,
    onClick = onClick,
)
```

See: https://issuetracker.google.com/issues/241154852 and the comment of the source code.

### Intrinsic Size

The [official documentation](https://developer.android.com/develop/ui/compose/layouts/intrinsic-measurements)
example for intrinsic measurements doesn't quite cover a common scenario.
Imagine you have two buttons in a Row, each with text of different lengths. The goal is to make both
buttons the same width, specifically matching the width of the widest button (so they both wrap its
content perfectly).

There are other methods to achieve this, but here I want to use `IntrinsicSize` to do it.

It's straightforward to make children in a Row have equal widths using `Modifier.weight(1f)`.
However,
this typically makes them expand to fill the available space. The challenge here is different: we
want to inform one child (or all children) about the preferred width of another (the widest one).
This implies needing to measure the children before determining the parent Row's size.

The documentation clearly explains how `Modifier.width(IntrinsicSize.Min)` functions in a Row. So,
how
does` Modifier.width(IntrinsicSize.Max)` behave in this context?

Let's take a quick peek at the source code.

Under the hood, `Row` is a custom layout. Its `MeasurePolicy` needs to implement functions from
`IntrinsicMeasureScope` to report its intrinsic sizes correctly. Following the call chain, we find
the
relevant code for [
`intrinsicMainAxisSize`](https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation-layout/src/commonMain/kotlin/androidx/compose/foundation/layout/RowColumnImpl.kt;l=415-438;drc=2c2677f4c3729b50080b6adf98d0c5e23d47d393) (
which determines intrinsic width for a Row)

```kotlin
private inline fun intrinsicMainAxisSize(
    children: List<IntrinsicMeasurable>,
    mainAxisSize: IntrinsicMeasurable.(Int) -> Int,
    crossAxisAvailable: Int,
    mainAxisSpacing: Int
): Int {
    if (children.isEmpty()) return 0
    var weightUnitSpace = 0
    var fixedSpace = 0
    var totalWeight = 0f
    children.fastForEach { child ->
        val weight = child.rowColumnParentData.weight
        val size = child.mainAxisSize(crossAxisAvailable)
        if (weight == 0f) {
            fixedSpace += size
        } else if (weight > 0f) {
            totalWeight += weight
            weightUnitSpace = max(weightUnitSpace, (size / weight).fastRoundToInt())
        }
    }
    return (weightUnitSpace * totalWeight).fastRoundToInt() +
        fixedSpace +
        (children.size - 1) * mainAxisSpacing
}
```

Notice how it considers the weight modifier. The key variable here is weightUnitSpace. It's
calculated as the **maximum** (intrinsic size / weight) ratio among all weighted children.

In our specific case, let's say both buttons have weight = 1f.

1. For each button, `child.mainAxisSize(crossAxisAvailable)` will return its intrinsic width (the
   width it needs to wrap its text).
2. `weightUnitSpace` will then be
   `max((intrinsic_width_button1 / 1f), (intrinsic_width_button2 / 1f))`.
   This simplifies to the width of the wider button.
3. `totalWeight` will be 1f + 1f = 2f.
4. Ignoring spacing and fixed-size children for clarity, the function returns`(
   width_of_wider_button * 2f)`.

Now we get it.

## Ktor logging

Add dependencies:

```toml
slf4j-android = { group = "org.slf4j", name = "slf4j-android", version.ref = "slf4jAndroid" }
ktor-client-logging = { group = "io.ktor", name = "ktor-client-logging", version.ref = "ktor" }
```

Then change logger:

```kotlin
val ktorfit = ktorfit {
    httpClient(HttpClient {
        install(Logging) {
            logger = Logger.ANDROID // <<< DEFAULT is nor working
            level = LogLevel.ALL
        }
    })
}
```

## `MutableStateFlow` vs `MutableState`

If you don't familiar with Kotlin flow, here is the key point:

`MutableStateFlow` is from Kotlin coroutines, which is a class from language official library. But
`MutableState` is a concept from Compose framework, basically the state in Compose is built on this.

So, since it is recommended to avoid reference UI staff in ViewModel, using `MutableStateFlow` as
public UiState in ViewModel is preferred.

See
also: https://developer.android.com/develop/ui/compose/state?hl=en#use-other-types-of-state-in-jetpack-compose

## Some words about OAUTH2 authentication on Android

- Standard Android implementation: [AppAuth-Android](https://github.com/openid/AppAuth-Android)
- A community KMP
  implementation: [kotlin-multiplatform-oidc](https://github.com/kalinjul/kotlin-multiplatform-oidc)

NeoDB/Mastodon has its quirk:

> At present, Mastodon does not support the Dynamic Client Registration protocol,
> however it does support a proprietary endpoint for registering an OAuth Application.
>
> At present Mastodon only supports confidential clients,
> however work is underway to add support for public clients.

See:

- https://docs.joinmastodon.org/spec/oauth/
- https://neodb.net/api/#how-to-authorize

So we should store client_secret in our end.

But
Android's [EncryptedSharedPreferences](https://developer.android.com/reference/androidx/security/crypto/EncryptedSharedPreferences)
is [deprecated](https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:security/security-crypto/src/main/java/androidx/security/crypto/EncryptedSharedPreferences.java;drc=83d0df9197c5320ac2e10d92afaf9ee839cec144;l=81),
and also both this and [KeyStore](https://developer.android.com/privacy-and-security/keystore)
is [not reliable](https://github.com/tink-crypto/tink/issues/535#issuecomment-912170221).

Besides, as the official alternative
to [SharedPreferences](https://developer.android.com/reference/android/content/SharedPreferences),
[DataStore](https://developer.android.com/topic/libraries/architecture/datastore) is recommended but
have no encryption function.
Although we have a community
library: [encrypted-datastore](https://github.com/osipxd/encrypted-datastore), it is preferred to
wait Google to achieve it officially.
Here is the [bug report](https://issuetracker.google.com/issues/167697691), 792 votes without any
response from Google.
